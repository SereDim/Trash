'''
1. Напишіть програми, що виконують такі операції з масивами (використовувати
вбудовані методи по роботі з масивами заборонено):
 виведіть на екран елементи лінійного масиву (заданий користувачем) у
зворотному порядку;
 виведіть на екран транспоновану матрицю 3*3 (початкова матриця задана
користувачем).
 виконайте добуток двох квадратних матриць 3*3, врахуйте розмірність.
Результати множення елементів занесіть до нової матриці та виведіть її на екран;
 у матриці 4*4, що задана користувачем замініть всі від’ємні елементи на 0.
Серебренников Дмитрий Александрович
'''
#1
import numpy#Модуль для массивов
a=int(input())#Ряд
b=int(input())#Столбец
c=numpy.zeros((a,b),dtype=numpy.int_)#Создание массива с нулей типа целочисленного 
for d in range(a-1,-1,-1):#Шаг -1 пчт в обратную сторону, окончание -1 пчт range не проходит полследнюю итер
    for e in range(b-1,-1,-1):#то же самое для столбцов
        c[d,e]=int(input('A['+str(e+1)+','+str(d+1)+']='))#Программа проходит по каждой итерации во время которой польз вводит значения, также был изменен порядок (е и д)
print(c)#
#2
c=numpy.zeros((3,3),dtype=numpy.int_)#
for d in range(-3,0):#Я удивляюсь как оно работает,
    for e in range(-3,0):#Но я его сделал делая первую
        c[e,d]=int(input('A['+str(d+3)+','+str(e+3)+']='))#Прибавил 3 пчт выходило за пределы возможных знач
print(c)#
#3
c=numpy.zeros((3,3),dtype=numpy.int_)#Делаем
for d in range(3):#Две
    for e in range(3):#Матрицы
        c[d,e]=int(input('A['+str(d)+','+str(e)+']='))#И
f=numpy.zeros((3,3),dtype=numpy.int_)#Просто
for k in range(3):#По всем
    for l in range(3):# Известной
        f[k,l]=int(input('A['+str(k)+','+str(l)+']='))#Фомруле
o=numpy.zeros((3,3),dtype=numpy.int_)#Подставляем
print(c)#
print(f)#
o[0,0]=c[0,0]*f[0,0]+c[0,1]*f[1,0]+c[0,2]*f[2,0]#Я пытался сделать через dif d(a,b,c): d(a*b*c)         d(c[::,::]) но оно подстваляет значения в первый аргумент
o[0,1]=c[0,0]*f[0,1]+c[0,1]*f[1,1]+c[0,2]*f[2,1]#Еще пробовал через for но он не принимает этот аргумент, поэтому решил сделать формулами
o[0,2]=c[0,0]*f[0,2]+c[0,1]*f[1,2]+c[0,2]*f[2,2]
o[1,0]=c[1,0]*f[0,0]+c[1,1]*f[1,0]+c[1,2]*f[2,0]
o[1,1]=c[1,0]*f[0,1]+c[1,1]*f[1,1]+c[1,2]*f[2,1]
o[1,2]=c[1,0]*f[0,2]+c[1,1]*f[1,2]+c[1,2]*f[2,2]
o[2,0]=c[2,0]*f[0,0]+c[2,1]*f[1,0]+c[2,2]*f[2,0]
o[2,1]=c[2,0]*f[0,1]+c[2,1]*f[1,1]+c[2,2]*f[2,1]
o[2,2]=c[2,0]*f[0,2]+c[2,1]*f[1,2]+c[2,2]*f[2,2]
print(o)#
#4 
#Четвёртое взял частично с лекции 11
p = int (input ( 'Кількість рядків ='))
q = int (input ( 'Кількість стовпців ='))
# Створення двовимірного масиву розміром p*q. Елементи
r = numpy.zeros ((p, q), dtype = numpy.int_)
# Заповнення масиву випадковими цілими числами.
for s in range(3):
    for t in range(3):
        r[s,t]=int(input('A['+str(s)+','+str(t)+']='))
# Виведення на екран початкового масиву.
count = 0#Это явно лишнее но в лекции 11 оно есть)
for u in range (p):
    for v in range (q):
        if r [u, v] <0:
            r [u, v] = 0
# Виведення результату обчислень на екран.
print ( 'результуючий масив: \ n', r)#Ещё одна ошибка с лекции)
